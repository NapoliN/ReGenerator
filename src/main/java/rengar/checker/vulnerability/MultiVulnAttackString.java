package rengar.checker.vulnerability;

import rengar.checker.attack.AttackString;
import rengar.config.GlobalConfig;

import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;

import rengar.parser.charutil.CharUtil;

public class MultiVulnAttackString {
    private final List<AttackString> attackStrings;
    private int[] postfix;

    public MultiVulnAttackString() {
        this.attackStrings = new ArrayList<>();
    }

    public void AddAttackString(AttackString attackString) {
        this.attackStrings.add(attackString);
    }

    public void setPostfix(int[] postfix) {
        this.postfix = postfix;
    }

    /**
     * 攻撃文字列の繰り返し回数を調整する
     */
    public void adjustmentNs() {
        // まず素朴な近似解を求める
        int k = attackStrings.size();
        int np = GlobalConfig.MaxYStringSum - attackStrings.stream().mapToInt(atk -> atk.getPrefix().length).sum() - this.postfix.length;
        int remain = np;
        for (int i = 0; i < k; i++){
            AttackString attackString = attackStrings.get(i);
            int ni = np / ((k+1)*attackString.getPumpLength());
            if (i == k-1){
                ni = ni * 2;
            }
            attackString.setN(ni);
            remain -= ni * attackString.getPumpLength();
        }
        // remain = capacity - sum(prefixes) - sum(pumps) - postifx
        // remain ... sum(k*pumpLength)くらいになるので、 O(k^2p)

        // DPで穴埋め
        np = remain;
        BigInteger[][] dp = new BigInteger[k+1][np+1];
        int[][] path = new int[k+1][np+1];
        // 初期化
        for (int i = 0; i <= k; i++){
            for (int j = 0; j <= np; j++){
                dp[i][j] = BigInteger.ONE;
            }
        }
        for (int i = 1; i <= k; i++){
            int pumpLen = attackStrings.get(i-1).getPumpLength();
            for (int j = 1; j <= np; j++){
                for (int l = 0; l <= j / pumpLen; l++){
                    var newcost = BigInteger.valueOf(pumpLen* Math.max(1,l));
                    if (i == k){
                        newcost = newcost.pow(2);
                    }
                    var cost = dp[i-1][j-pumpLen*l].multiply(newcost);
                    if (dp[i][j].compareTo(cost) < 0){
                        dp[i][j] = cost;
                        path[i][j] = l;
                    }
                }
            }
        }
        int j = np;
        for (int i = k; i >= 1; i--){
            int l = path[i][j];
            int current = attackStrings.get(i-1).getN();
            attackStrings.get(i-1).setN(current + l);
            j -= l*attackStrings.get(i-1).getPumpLength();
        }
    }

    public BigInteger estimatedMatchingStep(){
        BigInteger sum = BigInteger.ONE;
        for (int i=0; i<attackStrings.size(); i++){
            var cost = BigInteger.valueOf(attackStrings.get(i).getPumpLength() * attackStrings.get(i).getN());
            sum = sum.multiply(cost);
            if (i == attackStrings.size()-1){
                sum = sum.multiply(cost);
            }
        }
        return sum;
    }

    public String genStr() {
        StringBuilder sb = new StringBuilder();
        for (AttackString attackString : attackStrings) {
            sb.append(attackString.genStr());
        }
        sb.append(CharUtil.toString(postfix));
        return sb.toString();
    }

    public String genReadableString(){
        StringBuilder sb = new StringBuilder();
        for (AttackString attackString : attackStrings) {
            sb.append(attackString.genReadableStrWithoutPostfix());
            sb.append(" + ");
        }
        sb.append(CharUtil.toPrintableString(postfix));
        return sb.toString();
    }

    public int getLength(){
        int sum = 0;
        for (AttackString attackString : attackStrings) {
            sum += attackString.getPrefix().length;

            sum +=  attackString.getPumpLength() * attackString.getN();
        }
        sum += postfix.length;
        return sum;
    }
}
