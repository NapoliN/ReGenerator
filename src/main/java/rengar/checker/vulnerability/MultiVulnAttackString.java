package rengar.checker.vulnerability;

import rengar.checker.attack.AttackString;
import rengar.config.GlobalConfig;

import java.math.BigInteger;
import java.util.*;
import java.util.stream.Collectors;

import rengar.parser.charutil.CharUtil;

public class MultiVulnAttackString {
    private final List<AttackString> attackStrings;
    private int[] postfix;

    public MultiVulnAttackString() {
        this.attackStrings = new ArrayList<>();
    }

    public void AddAttackString(AttackString attackString) {
        this.attackStrings.add(attackString);
    }

    public void setPostfix(int[] postfix) {
        this.postfix = postfix;
    }

    /**
     * 攻撃文字列の繰り返し回数を調整する
     */
    public void adjustmentNs() {
        // FIXME 素朴な近似解
        int k = attackStrings.size();
        int np = GlobalConfig.MaxYStringLengthForPOA - attackStrings.stream().mapToInt(atk -> atk.getPumpLength()).sum() - this.postfix.length;
        // 少なくともこれだけは入る、という形で使える？
        
        for (int i = 0; i < k; i++){
            AttackString attackString = attackStrings.get(i);
            int ni = np / ((k+1)*attackString.getPumpLength());
            attackString.setN(ni);
        }
        
        // DPで書いてみる
        
        /**
        BigInteger[][] dp = new BigInteger[k+1][np+1];
        int[][] path = new int[k+1][np+1];
        // 初期化
        for (int i = 0; i <= k; i++){
            for (int j = 0; j <= np; j++){
                dp[i][j] = BigInteger.ONE;
            }
        }
        for (int i = 1; i <= k; i++){
            int pumpLen = attackStrings.get(i-1).getPumpLength();
            for (int j = 1; j <= np; j++){
                for (int l = 0; l <= j / pumpLen; l++){
                    var newcost = BigInteger.valueOf(pumpLen* Math.max(1,l));
                    if (i == k){
                        newcost = newcost.pow(2);
                    }
                    var cost = dp[i-1][j-pumpLen*l].multiply(newcost);
                    if (dp[i][j].compareTo(cost) < 0){
                        dp[i][j] = cost;
                        path[i][j] = l;
                    }
                }
            }
        }
        int j = np;
        for (int i = k; i >= 1; i--){
            int l = path[i][j];
            attackStrings.get(i-1).setN(l);
            j -= l*attackStrings.get(i-1).getPumpLength();
        }
        */
    }

    public BigInteger estimatedMatchingStep(){
        BigInteger sum = BigInteger.ONE;
        for (int i=0; i<attackStrings.size(); i++){
            var cost = BigInteger.valueOf(attackStrings.get(i).getPumpLength() * attackStrings.get(i).getN());
            sum = sum.multiply(cost);
            if (i == attackStrings.size()-1){
                sum = sum.multiply(cost);
            }
        }
        return sum;
    }

    public String genStr() {
        StringBuilder sb = new StringBuilder();
        for (AttackString attackString : attackStrings) {
            sb.append(attackString.genStr());
        }
        sb.append(CharUtil.toString(postfix));
        return sb.toString();
    }

    public String genReadableString(){
        StringBuilder sb = new StringBuilder();
        for (AttackString attackString : attackStrings) {
            sb.append(attackString.genReadableStrWithoutPostfix());
            sb.append(" + ");
        }
        sb.append(CharUtil.toPrintableString(postfix));
        return sb.toString();
    }
}
