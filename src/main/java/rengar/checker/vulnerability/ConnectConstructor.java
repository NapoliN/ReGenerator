package rengar.checker.vulnerability;

import rengar.parser.ast.*;

/**
 * 2つのLoopExprの間を補完する部分木を抽出するクラス
 */
public class ConnectConstructor {
    private Expr expr;
    private boolean flag = false;
    private boolean terminateFlag = false;

    public ConnectConstructor(Expr expr) {
        this.expr = expr;
    }

    /**
     * fromExprからtoExprの間を補完する部分木を抽出する
     * currentの部分木のうち、そのような部分木がなければnullを返す
     * @param current 参照している木
     * @param fromExpr 木の始点 (ループラベル)
     * @param toExpr 木の終点 (ループラベル)
     * @return
     */
    private Expr extractComplementalTreeExpr(Expr current, LoopExpr fromExpr, LoopExpr toExpr) {
        //System.out.println(current.getExprId());
        //System.out.println(current.getClass());
        switch(current){
            case SequenceExpr sequence -> {
                SequenceExpr newSequence = new SequenceExpr();
                newSequence.setExprId(sequence.getExprId());
                for (Expr expr : sequence.getExprs()) {
                    Expr newExpr = extractComplementalTreeExpr(expr, fromExpr, toExpr);
                    // 何も返ってこなかったらスキップ
                    if(newExpr == null){
                        continue;
                    }
                    if (terminateFlag) {
                        newSequence.add(newExpr);
                        break;
                    }
                    // Toを見つけたら入れずに終わり
                    if (newExpr.getExprId() == toExpr.getExprId()){
                        flag = false;
                        terminateFlag = true;
                        //System.out.println("ここまで");
                        break;
                    }

                    //System.out.println("addした");
                    if (flag){
                        newSequence.add(newExpr);
                    }


                    if (newExpr.getExprId() == fromExpr.getExprId()){
                        flag = true;
                        //System.out.println("ここから");
                    }
                }
                if(newSequence.isEmpty()){
                    //System.out.println("empty---");
                    return null;
                }
                
                return newSequence;
            }
            case BranchExpr branchExpr -> {
                BranchExpr newBranch = new BranchExpr();
                newBranch.setExprId(branchExpr.getExprId());
                for (Expr expr : branchExpr.getBranchs()) {
                    Expr newExpr = extractComplementalTreeExpr(expr, fromExpr, toExpr);
                    if(newExpr == null){
                        continue;
                    }
                    // Branch中のいずれかの要素がtoかfromなら、いらない
                    if (newExpr.getExprId() == fromExpr.getExprId()){
                        flag = true;
                        return null;
                    }
                    if (newExpr.getExprId() == toExpr.getExprId()){
                        flag = false;
                        return null;
                    }
                    newBranch.add((SequenceExpr)newExpr);
                    //System.out.println("addした" + newExpr.getExprId());
                }
                if (newBranch.getBranchs().isEmpty()){
                    return null;
                }

                return newBranch;
            }
            case LoopExpr loopExpr -> {
                // 所望のループ構造を見つけたとき
                if (loopExpr.getExprId() == fromExpr.getExprId() || loopExpr.getExprId() == toExpr.getExprId()){
                    return loopExpr.copy();
                }
                Expr body = extractComplementalTreeExpr(loopExpr.getBody(), fromExpr, toExpr);
                if (body == null){
                    return null;
                }
                LoopExpr newLoop = loopExpr.copy();
                newLoop.setBody(body);
                if(flag || terminateFlag){
                    return newLoop;
                }
                return null;
            }
            case GroupExpr groupExpr-> {
                return extractComplementalTreeExpr(groupExpr.getBody(), fromExpr, toExpr);
            }
            case RegexExpr regexExpr -> {
                return extractComplementalTreeExpr(regexExpr.getExpr(), fromExpr, toExpr);
            }
            case CharExpr charExpr -> {
                if (flag || terminateFlag){
                    return charExpr;
                }
                return null;
            }
            default -> {
                return null;
            }
        }

    }
    public Expr extractComplementalTreeExpr(LoopExpr fromExpr, LoopExpr toExpr) {
        return extractComplementalTreeExpr(this.expr, fromExpr, toExpr);
    }
}
