package rengar.checker.vulnerability;

import java.util.*;

import rengar.checker.attack.AttackString;
import rengar.checker.pattern.DisturbFreePattern;
import rengar.checker.pattern.POAPattern;
import rengar.checker.pattern.ReDoSPattern;
import rengar.parser.ast.*;

// 脆弱性に対応するattackableノードと、攻撃の生成に成功したattack stringを管理するクラス
public class Vulnerability {
    private final POAPattern pattern;
    private final AttackString attackString;
    private final int id;

    public Vulnerability(POAPattern pattern,AttackString attackString, int id) {
        this.pattern = pattern;
        this.attackString = attackString;
        this.id = id;
    }

    public POAPattern getReDoSPattern() {
        return pattern;
    }

    public AttackString getAttackString() {
        return attackString;
    }

    // 2つの脆弱性a, b上の関係
    public enum Comparator {
        PRECEED, // a は bの手前である
        EQUAL, // a は b と同じ位置である
        FOLLOW, // a は bの後ろである
        CONTAIN, // a は b を真部分集合として含む
        CONTAINED, // a は b の真部分集合として含まれる
        Uncomparable, // その他 (a と b は常に排他的である)
        UnImplemented;
    }

    // 2つの脆弱性の位置関係を判定する
    public static Comparator compare(Vulnerability vuln1, Vulnerability vuln2){
        // 基になる正規表現は両者とも等しい
        RegexExpr baseExpr = vuln1.getReDoSPattern().getExpr();
        POAPattern poa1 = vuln1.getReDoSPattern();
        POAPattern poa2 = vuln2.getReDoSPattern();

        LoopExpr pre1 = poa1.getPreLoopExpr();
        SequenceExpr med1 = poa1.getMiddleSequenceExpr();
        LoopExpr post1 = poa1.getPostLoopExpr();
        
        LoopExpr pre2 = poa2.getPreLoopExpr();
        SequenceExpr med2 = poa2.getMiddleSequenceExpr();
        LoopExpr post2 = poa2.getPostLoopExpr();

        // IDの列を取る
        var id1arr = new ArrayList();
        var id2arr = new ArrayList();
        
        id1arr.add(pre1.getExprId());
        if(med1 != null)
            id1arr.addAll(med1.getExprs().stream().map(Expr::getExprId).toList());
        id1arr.add(post1.getExprId());

        id2arr.add(pre2.getExprId());
        if(med2 != null)
            id2arr.addAll(med2.getExprs().stream().map(Expr::getExprId).toList());
        id2arr.add(post2.getExprId());

        // 2つのID列の包含関係を調べる
        var contain = id1arr.containsAll(id2arr);
        var contained = id2arr.containsAll(id1arr);
        if (contain && contained){
            return Comparator.EQUAL;
        }
        else if (contain){
            return Comparator.CONTAIN;
        }
        else if (contained){
            return Comparator.CONTAINED;
        }

        // return Comparator.UnImplemented;
        System.out.println(String.format("alpha= %d %d, beta %d %d", pre1.getExprId(), post1.getExprId(), pre2.getExprId(), post2.getExprId()));

        // a0 to b0 かつ a2 to b0 ならば a preceeds to b
        if (pre1.getExprId() < pre2.getExprId()){
            var ancestor = baseExpr.getCommonAncestor(post1.getExprId(), pre2.getExprId());
            System.out.println(String.format("ancestorid %d, alpha2 %d, beta0 %d", ancestor.getExprId(), post1.getExprId(), pre2.getExprId()));
            if (ancestor instanceof LoopExpr || (ancestor instanceof SequenceExpr && post1.getExprId() < pre2.getExprId())){
                return Comparator.PRECEED;
            }
        }
        // b0 to a0 かつ b2 to a0 ならば a is followed by b
        if (pre2.getExprId() < pre1.getExprId()){
            var ancestor = baseExpr.getCommonAncestor(post2.getExprId(), pre1.getExprId());
            if (ancestor instanceof LoopExpr || (ancestor instanceof SequenceExpr && post2.getExprId() < pre1.getExprId())){
                return Comparator.FOLLOW;
            }
        }
        
        return Comparator.Uncomparable;

        /**
        Expr commonAncestor = Expr.getCommonAncestorExpr(med1, med2);
        if (commonAncestor instanceof BranchExpr){
            return Comparator.Uncomparable;
        }
        else if (commonAncestor instanceof SequenceExpr){
            boolean is1Preceed = med1.getExprId() < med2.getExprId();

            return is1Preceed ? Comparator.PRECEED : Comparator.FOLLOW;
        }
        
        //vuln1.getReDoSPattern().getAttackableExpr()
        return Comparator.EQUAL;
        */

    }

    public String toJSONString(){
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append(String.format("\"id\": %d,",id));
        sb.append("\"attackable\":");
        sb.append(pattern.getAttackableExpr().genJsonExpression());
        sb.append(",\"preLoop\":");
        sb.append(pattern.getPreLoopExpr().genJsonExpression());
        if(pattern.getMiddleSequenceExpr() == null){
            sb.append(",\"middle\":null");
        }
        else{
            sb.append(",\"middle\":");
            sb.append(pattern.getMiddleSequenceExpr().genJsonExpression());
        }
        sb.append(",\"postLoop\":");
        sb.append(pattern.getPostLoopExpr().genJsonExpression());
        sb.append("}");
        return sb.toString();
    }
}