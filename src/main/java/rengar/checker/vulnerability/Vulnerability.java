package rengar.checker.vulnerability;

import java.util.*;
import java.util.concurrent.ExecutionException;

import rengar.checker.attack.AttackString;
import rengar.checker.pattern.DisturbFreePattern;
import rengar.checker.pattern.POAPattern;
import rengar.checker.pattern.ReDoSPattern;
import rengar.parser.ast.*;

// 脆弱性に対応するattackableノードと、攻撃の生成に成功したattack stringを管理するクラス
public class Vulnerability {
    private final POAPattern pattern;
    private final AttackString attackString;
    private final int id;

    public Vulnerability(POAPattern pattern,AttackString attackString, int id) {
        this.pattern = pattern;
        this.attackString = attackString;
        this.id = id;
    }

    public int getID(){
        return id;
    }

    public POAPattern getReDoSPattern() {
        return pattern;
    }

    public AttackString getAttackString() {
        return attackString;
    }

    // 2つの脆弱性a, b上の関係
    public enum Comparator {
        PRECEED, // a は bの手前である
        EQUAL, // a は b と同じ位置である
        FOLLOW, // a は bの後ろである
        CONTAIN, // a は b を真部分集合として含む
        CONTAINED, // a は b の真部分集合として含まれる
        Uncomparable, // その他 (a と b は常に排他的である)
        UnImplemented;
    }

    // 2つの脆弱性の位置関係を判定する
    public static Comparator compare(RegexExpr baseExpr, Vulnerability alpha, Vulnerability beta) throws IndexOutOfBoundsException{
        // 基になる正規表現は両者とも等しい
        //RegexExpr baseExpr = alpha.getReDoSPattern().getExpr();
        POAPattern poa_alpha = alpha.getReDoSPattern();
        POAPattern poa_beta = beta.getReDoSPattern();

        LoopExpr alpha0 = poa_alpha.getPreLoopExpr();
        SequenceExpr alpha1 = poa_alpha.getMiddleSequenceExpr();
        LoopExpr alpha2 = poa_alpha.getPostLoopExpr();
        
        LoopExpr beta0 = poa_beta.getPreLoopExpr();
        SequenceExpr beta1 = poa_beta.getMiddleSequenceExpr();
        LoopExpr beta2 = poa_beta.getPostLoopExpr();

        // IDの列を取る
        var id1arr = new ArrayList();
        var id2arr = new ArrayList();
        
        id1arr.add(alpha0.getExprId());
        if(alpha1 != null)
            id1arr.addAll(alpha1.getExprs().stream().map(Expr::getExprId).toList());
        id1arr.add(alpha2.getExprId());

        id2arr.add(beta0.getExprId());
        if(beta1 != null)
            id2arr.addAll(beta1.getExprs().stream().map(Expr::getExprId).toList());
        id2arr.add(beta2.getExprId());

        // 2つのID列の包含関係を調べる
        var contain = id1arr.containsAll(id2arr);
        var contained = id2arr.containsAll(id1arr);
        if (contain && contained){
            return Comparator.EQUAL;
        }
        else if (contain){
            return Comparator.CONTAIN;
        }
        else if (contained){
            return Comparator.CONTAINED;
        }

        // a0 to b0 かつ a2 to b0 ならば a preceeds to b
        if (alpha0.getExprId() < beta0.getExprId()){
            var ancestor = baseExpr.getCommonAncestor(alpha2.getExprId(), beta0.getExprId());
            //System.out.println(String.format("ancestorid %d, alpha2 %d, beta0 %d", ancestor.getExprId(), alpha2.getExprId(), beta0.getExprId()));
            if (ancestor instanceof LoopExpr || (ancestor instanceof SequenceExpr && alpha2.getExprId() < beta0.getExprId())){
                return Comparator.PRECEED;
            }
        }
        // b0 to a0 かつ b2 to a0 ならば a is followed by b
        if (beta0.getExprId() < alpha0.getExprId()){
            var ancestor = baseExpr.getCommonAncestor(beta2.getExprId(), alpha0.getExprId());
            //System.out.println(String.format("ancestorid %d, beta2 %d, alpha0 %d", ancestor.getExprId(), beta2.getExprId(), alpha0.getExprId()));
            if (ancestor instanceof LoopExpr || (ancestor instanceof SequenceExpr && beta2.getExprId() < alpha0.getExprId())){
                return Comparator.FOLLOW;
            }
        }
        
        return Comparator.Uncomparable;
    }

    public String toJSONString(){
        StringBuilder sb = new StringBuilder();
        sb.append("{");
        sb.append(String.format("\"id\": %d,",id));
        sb.append("\"attackable\":");
        sb.append(pattern.getAttackableExpr().genJsonExpression());
        sb.append(",\"preLoop\":");
        sb.append(pattern.getPreLoopExpr().genJsonExpression());
        if(pattern.getMiddleSequenceExpr() == null){
            sb.append(",\"middle\":null");
        }
        else{
            sb.append(",\"middle\":");
            sb.append(pattern.getMiddleSequenceExpr().genJsonExpression());
        }
        sb.append(",\"postLoop\":");
        sb.append(pattern.getPostLoopExpr().genJsonExpression());
        sb.append("}");
        return sb.toString();
    }
}